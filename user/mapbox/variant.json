{"_default": {"1": {"SergeyIvanov87": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/164", "title": "Possible data corruption when assigning variant to itself", "body": "Hi, Thanks to you variant implementation!\r\nBut i see, that there are issue in member\r\n```\r\nVARIANT_INLINE variant<Types...>& operator=(variant<Types...> const& other)\r\n{\r\n    copy_assign(other);\r\n    return *this;\r\n}\r\n```\r\n\r\n\r\nNow there are no check for `&other ==this` and `copy_assign` can destroy variant member data's before actual copy  to itself\r\n```\r\nVARIANT_INLINE void copy_assign(variant<Types...> const& rhs)\r\n{\r\n    helper_type::destroy(type_index, &data);\r\n    type_index = detail::invalid_value;\r\n    helper_type::copy(rhs.type_index, &rhs.data, &data);\r\n    type_index = rhs.type_index;\r\n}\r\n```\r\n\r\nSo, in result `helper_type::copy(rhs.type_index, &rhs.data, &data);` can operate with invalid data\r\n\r\nBest Regards", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/164/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}], "commits": [], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": []}, "springmeyer": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/158", "title": "Fixing clang-tidy errors/warnings", "body": "I'm attempting to set up clang-tidy to run on codebases using `variant`. I am consistently seeing most warnings coming from variant. So these need to be addressed here, at the source, by either adding `// NOLINT` where appropriate or fixing.\r\n\r\n@artemp can you please tackle this next week?\r\n\r\nHere are the warnings:\r\n\r\n<details>\r\n```\r\n./include/mapbox/variant.hpp:344:16: warning: Function call argument is an uninitialized value [clang-analyzer-core.CallAndMessage]\r\n        return f(unwrapper<T>::apply(v.template get_unchecked<T>()));\r\n               ^\r\ntest/lambda_overload_test.cpp:122:5: note: Calling 'test_match_singleton'\r\n    test_match_singleton();\r\n    ^\r\ntest/lambda_overload_test.cpp:87:5: note: Calling 'variant::match'\r\n    singleton.match([](int) {});\r\n    ^\r\n./include/mapbox/variant.hpp:903:16: note: Calling 'variant::visit'\r\n        return variant::visit(*this, ::mapbox::util::make_visitor(std::forward<Fs>(fs)...));\r\n               ^\r\n./include/mapbox/variant.hpp:871:16: note: Calling 'dispatcher::apply'\r\n        return detail::dispatcher<F, V, R, Types...>::apply(v, std::forward<F>(f));\r\n               ^\r\n./include/mapbox/variant.hpp:344:18: note: Calling 'unwrapper::apply'\r\n        return f(unwrapper<T>::apply(v.template get_unchecked<T>()));\r\n                 ^\r\n./include/mapbox/variant.hpp:344:18: note: Returning from 'unwrapper::apply'\r\n        return f(unwrapper<T>::apply(v.template get_unchecked<T>()));\r\n                 ^\r\n./include/mapbox/variant.hpp:344:16: note: Function call argument is an uninitialized value\r\n        return f(unwrapper<T>::apply(v.template get_unchecked<T>()));\r\n               ^\r\n2 warnings generated.\r\n./include/mapbox/recursive_wrapper.hpp:106:36: warning: Undefined or garbage value returned to caller [clang-analyzer-core.uninitialized.UndefReturn]\r\n    const T* get_pointer() const { return p_; }\r\n                                   ^\r\ntest/hashable_test.cpp:157:5: note: Calling 'test_recursive_hashable'\r\n    test_recursive_hashable();\r\n    ^\r\ntest/hashable_test.cpp:142:10: note: Calling move constructor for 'variant'\r\n    Tree tree = Node{Node{Empty{}, Empty{}}, Empty{}};\r\n         ^\r\n./include/mapbox/variant.hpp:615:9: note: Calling 'variant_helper::move'\r\n        helper_type::move(old.type_index, &old.data, &data);\r\n        ^\r\n./include/mapbox/variant.hpp:235:9: note: Taking false branch\r\n        if (old_type_index == sizeof...(Types))\r\n        ^\r\n./include/mapbox/variant.hpp:241:13: note: Calling 'variant_helper::move'\r\n            variant_helper<Types...>::move(old_type_index, old_value, new_value);\r\n            ^\r\n./include/mapbox/variant.hpp:235:9: note: Taking false branch\r\n        if (old_type_index == sizeof...(Types))\r\n        ^\r\n./include/mapbox/variant.hpp:241:13: note: Calling 'variant_helper::move'\r\n            variant_helper<Types...>::move(old_type_index, old_value, new_value);\r\n            ^\r\n./include/mapbox/variant.hpp:241:13: note: Returning from 'variant_helper::move'\r\n            variant_helper<Types...>::move(old_type_index, old_value, new_value);\r\n            ^\r\n./include/mapbox/variant.hpp:241:13: note: Returning from 'variant_helper::move'\r\n            variant_helper<Types...>::move(old_type_index, old_value, new_value);\r\n            ^\r\n./include/mapbox/variant.hpp:615:9: note: Returning from 'variant_helper::move'\r\n        helper_type::move(old.type_index, &old.data, &data);\r\n        ^\r\ntest/hashable_test.cpp:142:10: note: Returning from move constructor for 'variant'\r\n    Tree tree = Node{Node{Empty{}, Empty{}}, Empty{}};\r\n         ^\r\ntest/hashable_test.cpp:144:9: note: Calling 'hash::operator()'\r\n    if (std::hash<Tree>{}(tree) != ((5 + (5 + (3 + 3))) + 3))\r\n        ^\r\n./include/mapbox/variant.hpp:1022:16: note: Calling 'apply_visitor'\r\n        return ::mapbox::util::apply_visitor(::mapbox::util::detail::hasher{}, v);\r\n               ^\r\n./include/mapbox/variant.hpp:959:12: note: Calling 'variant::visit'\r\n    return V::visit(v, std::forward<F>(f));\r\n           ^\r\n./include/mapbox/variant.hpp:864:16: note: Calling 'dispatcher::apply_const'\r\n        return detail::dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f));\r\n               ^\r\n./include/mapbox/variant.hpp:311:9: note: Taking false branch\r\n        if (v.template is<T>())\r\n        ^\r\n./include/mapbox/variant.hpp:317:20: note: Calling 'dispatcher::apply_const'\r\n            return dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f));\r\n                   ^\r\n./include/mapbox/variant.hpp:339:18: note: Calling 'unwrapper::apply_const'\r\n        return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\r\n                 ^\r\n./include/mapbox/variant.hpp:279:16: note: Calling 'recursive_wrapper::get'\r\n        return obj.get();\r\n               ^\r\n./include/mapbox/recursive_wrapper.hpp:101:17: note: Calling 'recursive_wrapper::get_pointer'\r\n        return *get_pointer();\r\n                ^\r\n./include/mapbox/recursive_wrapper.hpp:106:36: note: Undefined or garbage value returned to caller\r\n    const T* get_pointer() const { return p_; }\r\n                                   ^\r\n./include/mapbox/variant.hpp:555:16: warning: Function call argument is an uninitialized value [clang-analyzer-core.CallAndMessage]\r\n        return std::hash<T>{}(hashable);\r\n               ^\r\ntest/hashable_test.cpp:153:5: note: Calling 'test_singleton'\r\n    test_singleton();\r\n    ^\r\ntest/hashable_test.cpp:17:7: note: Calling move constructor for 'variant'\r\n    V singleton = 5;\r\n      ^\r\n./include/mapbox/variant.hpp:615:9: note: Calling 'variant_helper::move'\r\n        helper_type::move(old.type_index, &old.data, &data);\r\n        ^\r\n./include/mapbox/variant.hpp:235:9: note: Taking false branch\r\n        if (old_type_index == sizeof...(Types))\r\n        ^\r\n./include/mapbox/variant.hpp:241:13: note: Calling 'variant_helper::move'\r\n            variant_helper<Types...>::move(old_type_index, old_value, new_value);\r\n            ^\r\n./include/mapbox/variant.hpp:241:13: note: Returning from 'variant_helper::move'\r\n            variant_helper<Types...>::move(old_type_index, old_value, new_value);\r\n            ^\r\n./include/mapbox/variant.hpp:615:9: note: Returning from 'variant_helper::move'\r\n        helper_type::move(old.type_index, &old.data, &data);\r\n        ^\r\ntest/hashable_test.cpp:17:7: note: Returning from move constructor for 'variant'\r\n    V singleton = 5;\r\n      ^\r\ntest/hashable_test.cpp:19:9: note: Calling 'hash::operator()'\r\n    if (std::hash<V>{}(singleton) != std::hash<int>{}(5))\r\n        ^\r\n./include/mapbox/variant.hpp:1022:16: note: Calling 'apply_visitor'\r\n        return ::mapbox::util::apply_visitor(::mapbox::util::detail::hasher{}, v);\r\n               ^\r\n./include/mapbox/variant.hpp:959:12: note: Calling 'variant::visit'\r\n    return V::visit(v, std::forward<F>(f));\r\n           ^\r\n./include/mapbox/variant.hpp:864:16: note: Calling 'dispatcher::apply_const'\r\n        return detail::dispatcher<F, V, R, Types...>::apply_const(v, std::forward<F>(f));\r\n               ^\r\n./include/mapbox/variant.hpp:339:18: note: Calling 'unwrapper::apply_const'\r\n        return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\r\n                 ^\r\n./include/mapbox/variant.hpp:339:18: note: Returning from 'unwrapper::apply_const'\r\n        return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\r\n                 ^\r\n./include/mapbox/variant.hpp:339:18: note: Passing value via 1st parameter 'hashable'\r\n        return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\r\n                 ^\r\n./include/mapbox/variant.hpp:339:16: note: Calling 'hasher::operator()'\r\n        return f(unwrapper<T>::apply_const(v.template get_unchecked<T>()));\r\n               ^\r\n./include/mapbox/variant.hpp:555:16: note: Function call argument is an uninitialized value\r\n        return std::hash<T>{}(hashable);\r\n```\r\n</details>\r\n\r\n\r\nHere is how I'm testing:\r\n\r\n - ` run-clang-tidy` branch: https://github.com/mapbox/variant/compare/run-clang-tidy\r\n - Running `./scripts/clang-tidy.sh` \r\n\r\n/cc @daniel-j-h \r\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/158/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/19", "title": "sizeof(variant)", "body": "My understanding is that calling `sizeof` on a variant should produce the size of the largest type the variant includes.  And my assumption is that `sizeof` for a given type is not going to be consistent/portable across arches and platforms. However, as we should strive to have the variant use at little memory as possible I wanted to surface this ticket for discussion.\n\nDumb questions that I assume the answer is `duh, no`, but want to know for sure:\n- Would it make sense to try to add tests of `sizeof(variant_instance)` by adapting to how `sizeof(std::string)` and other types might be different per platform? Might catch regressions if we ever made a mistake that increased the variant memory footprint.\n- Are there any optimizations to be had from learning/applying ideas from http://www.catb.org/esr/structure-packing/?\n- For custom types should we add some kind of MAX_VARIANT_SIZEOF flag to allow clamping the size - this would then be able to catch a situation were a poorly aligned custom type is larger than other built-in types used in the variant\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/19/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}], "commits": [], "pull_requests": [], "issue_comments": [{"url": "https://api.github.com/repos/mapbox/variant/issues/comments/41803797", "body": "Awesome, let's do it. \n\n> On Apr 30, 2014, at 7:32 AM, Dennis Luxen notifications@github.com wrote:\n> \n> awesome, it would allow me to ditch yet another boost dependency in OSRM. (not that boost is bad at all)\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/41803797/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/43557494", "body": "This is now in place. Next actions are more tests and small fixups (#13)\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/43557494/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/43942322", "body": "removed as part of https://github.com/mapbox/variant/commit/64f8fb4473f3ef6f7117dc02f02a20645e415b72\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/43942322/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44199345", "body": "Hmm, maybe try (untested):\n\nobject.values[\"pi\"] = std::move(number);\n\nAlso see the recursive wrapper tests using unique_ptr in tests/ for usage hints. \n\n> On May 26, 2014, at 8:20 AM, Dennis Luxen notifications@github.com wrote:\n> \n> The following code snippet is not compiling:\n> \n> #include \"recursive_wrapper.hpp\"\n> #include \"variant.hpp\"\n> \n> #include <iostream>\n> #include <string>\n> #include <unordered_map>\n> \n> struct Number;\n> struct Object;\n> \n> typedef util::variantutil::recursive_wrapper<Number,\n>                       util::recursive_wrapper<Object>> Value;\n> struct Number\n> {\n>     Number() {}\n>     Number(double value) : value(value) {}\n>     double value;\n> };\n> \n> struct Object\n> {\n>     std::unordered_map<std::string, Value> values;\n> };\n> \n> int main() {\n>     Object object;\n>     Number number {3.1415};\n>     object.values[\"pi\"] = number; \n>     return 0;\n> }\n> Fails on clang 3.4 with:\n> \n> $ clang++ test/variant_hello_world.cpp -std=c++11 -I . && ./a.out \n> In file included from test/variant_hello_world.cpp:2:\n> ./variant.hpp:397:9: error: static_assert failed \"Not a valid type for this variant\"\n>         static_assert(detail::is_valid_type<T,Types...>::value, \"Not a valid type for this variant\");\n>         ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n> test/variant_hello_world.cpp:28:27: note: in instantiation of function template specialization 'util::variantutil::recursive_wrapper<Number, util::recursive_wrapper<Object> >::variant<Number &>' requested here\n>     object.values[\"pi\"] = number; \n>                           ^\n> In file included from test/variant_hello_world.cpp:2:\n> ./variant.hpp:398:21: error: cannot allocate reference type 'Number &' with new\n>         new (&data) T(std::forward<T>(val)); // nothrow\n>                     ^\n> test/variant_hello_world.cpp:28:27: note: in instantiation of function template specialization 'util::variantutil::recursive_wrapper<Number, util::recursive_wrapper<Object> >::variant<Number &>' requested here\n>     object.values[\"pi\"] = number; \n>                           ^\n> 2 errors generated.\n> and on GCC 4.8.1 with:\n> \n> $ g++ test/variant_hello_world.cpp -std=c++11 -I . && ./a.out \n> In file included from test/variant_hello_world.cpp:2:0:\n> ./variant.hpp: In instantiation of \u2018util::variant<Types>::variant(T&&) [with T = Number&; Types = {util::recursive_wrapper<Number>, util::recursive_wrapper<Object>}]\u2019:\n> test/variant_hello_world.cpp:28:25:   required from here\n> ./variant.hpp:397:9: error: static assertion failed: Not a valid type for this variant\n>          static_assert(detail::is_valid_type<T,Types...>::value, \"Not a valid type for this variant\");\n>          ^\n> ./variant.hpp:398:9: error: new cannot be applied to a reference type\n>          new (&data) T(std::forward<T>(val)); // nothrow\n>          ^\n> \u2014\n> Reply to this email directly or view it on GitHub.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44199345/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44436105", "body": ":+1 from @artemp in chat, merging.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44436105/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45293352", "body": "@DennisOSRM - had a change to try this out again?\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45293352/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}], "commit_comments": [{"url": "https://api.github.com/repos/mapbox/variant/comments/5355288", "body": "okay :) :+1: \n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/comments/5355288/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/comments/6825636", "body": ":+1: \n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/comments/6825636/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/comments/15593940", "body": ":+1: \n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/comments/15593940/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/comments/17435758", "body": "\ud83d\udc4d  That need for `-stdlib=libc++` was for older OS X, clang++. Should be good to remove it now like you did.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/comments/17435758/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}], "review_comments": []}, "anandthakker": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/157", "title": "Add API.md documenting all available methods", "body": "Quoting @artemp from https://github.com/mapbox/variant/pull/156#discussion_r127658875:\r\n\r\n> it'll be better to have a separate page listing all available methods while README only mentions basic building blocks\r\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/157/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}], "commits": [], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/126270170", "body": "> Should we document all of variant's api here?\r\n\r\n@daniel-j-h good questions!  I wasn't aware of the other parts of variant's API either.  Motivation for this PR was simply that I found myself wishing for an `is<T>()` method and assuming it didn't exist because it wasn't in the readme (and the header code itself isn't too easy to skim as a reference).", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/126270170/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/129057405", "body": "\ud83d\udc4d closing here in favor of opening an issue re: documentation", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/129057405/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}]}, "BlueSolei": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/155", "title": "Visual Studio debugger support", "body": "I created a Visual Studio Native Visualizer file for variant.\r\nThis file enable the debugger to view the value in a variant variable. \r\nThere are two files here:\r\n\r\n1. Variant.natvis - the XML describe how to view the variant in VS debugger\r\n2. InstallVSDebuggerVariantSupport.bat - simple batch file to copy the nativs file to VS debugger folder\r\n3. One can also just add it to the project itself, the debugger will peek it up from there.\r\n\r\nThe natvis file support up to 20 types, if you think we need to support more, tell me and I will upload a new file.\r\nVS Natvis format requires to explicitly describe each variant (with 1, 2, 3... types).\r\nI use the boost::variant nativs file as a reference, and there it describe up to 20.\r\n\r\nEnjoy :-)\r\n\r\n[VariantVSDebuggerSupoort.zip](https://github.com/mapbox/variant/files/1117851/VariantVSDebuggerSupoort.zip)\r\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/155/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "commits": [{"url": "https://api.github.com/repos/mapbox/variant/commits/7a541ba10d2eb9a9da0f11bb27319cd125d43a3d", "message": "recursive_wrapper fail to compile when used with 2 classes which are base and derived #146"}], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": []}, "huanncbg": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/152", "title": "Bug leads to crash program when using .set<T>() and then apply_visitor() ", "body": "\r\n#include <iostream>\r\n#include <mapbox/variant.hpp>\r\n#include <unordered_map>\r\nusing namespace std;\r\nusing namespace mapbox::util;\r\n\r\n// Forward declaration\r\nstruct HPArray;\r\nstruct HPTable;\r\nusing HPVariant = variant<string,float,recursive_wrapper<HPArray>>;\r\n\r\nstruct HPArray{\r\n    template <typename ...Args>\r\n    HPArray(Args ...args){\r\n        values.emplace(std::forward<Args>(args)...);\r\n    }\r\n    unordered_map<int,HPVariant> values;\r\n};\r\n\r\nstruct Visitor{\r\n\r\n    void operator()(const string &str){\r\n        cout << str <<endl;;\r\n    }\r\n\r\n    void operator()(const float &value){\r\n        cout << value <<endl;\r\n    }\r\n\r\n    void operator()(HPArray array){\r\n        for (size_t i = 0; i < array.values.size(); i++)\r\n        {\r\n            apply_visitor(*this,array.values[i]);\r\n        }\r\n    }\r\n\r\n};\r\n\r\nint main()\r\n{\r\n    HPArray ar;\r\n    ar.values[0] = HPVariant(\"String\");\r\n    ar.values[1] = 2.0f;\r\n\r\n    HPVariant var;\r\n    var.set<HPArray>(ar);\r\n    Visitor visitor;\r\n    apply_visitor(visitor,var);\r\n    return 0;\r\n}\r\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/152/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}], "commits": [], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": []}, "jplatte": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/151", "title": "std::is_copy_constructible::value is always true for variant<Ts...>", "body": "The copy constructor only actually compiles when all member types are copyable, as it should. However, when checking whether the variant type is copy-constructible via SFINAE, e.g. with `std::is_copy_constructible`, you will always get `true`, because the copy constructor always exists, whether or not it is valid. The same applies to move constructors, and copy / move assignment operators.\r\n\r\nI first thought I could fix this with a simple `enable_if` on each of the methods, but as it turns out I can't because if you make templates out of any of these special methods, they are not those special methods anymore. I did find a [solution] on StackOverflow, though I'm not entirely certain if it might introduce unwanted side effects. Could you have a look? In case it seems unproblematic to you, I would be happy to try implementing it here.\r\n\r\n[solution]: https://stackoverflow.com/a/27073263/1592377", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/151/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}], "commits": [], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": []}, "tomhughes": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/148", "title": "Tests fail with gcc 7.0.1 due to new aliasing warnings", "body": "Running `make test` with gcc 7.0.1 fails due to new aliasing warnings, promoted to errors by the `-Werror` switch in the makefile:\r\n\r\n```\r\ng++ -c -o out/binary_visitor_1.o test/t/binary_visitor_1.cpp -Iinclude -isystem test/include -std=c++11 -Werror -Wall -Wextra -pedantic -Wformat=2 -Wsign-conversion -Wshadow -Wunused-parameter -O3 -DNDEBUG -march=native -DSINGLE_THREADED -fvisibility-inlines-hidden -fvisibility=hidden -I/usr/include/catch -pthread\r\nIn file included from test/t/binary_visitor_1.cpp:2:0:\r\ninclude/mapbox/variant.hpp: In instantiation of \u2018T& mapbox::util::variant<Types>::get() [with T = int; typename std::enable_if<(mapbox::util::detail::direct_type<T, Types ...>::index != mapbox::util::detail::invalid_value)>::type* <anonymous> = 0; Types = {int, double}]\u2019:\r\ntest/t/binary_visitor_impl.hpp:180:9:   required from here\r\ninclude/mapbox/variant.hpp:724:20: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]\r\n             return *reinterpret_cast<T*>(&data);\r\n                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ninclude/mapbox/variant.hpp: In instantiation of \u2018T& mapbox::util::variant<Types>::get() [with T = double; typename std::enable_if<(mapbox::util::detail::direct_type<T, Types ...>::index != mapbox::util::detail::invalid_value)>::type* <anonymous> = 0; Types = {int, double}]\u2019:\r\ntest/t/binary_visitor_impl.hpp:187:9:   required from here\r\ninclude/mapbox/variant.hpp:724:20: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]\r\ninclude/mapbox/variant.hpp: In instantiation of \u2018const T& mapbox::util::variant<Types>::get_unchecked() const [with T = int; typename std::enable_if<(mapbox::util::detail::direct_type<T, Types ...>::index != mapbox::util::detail::invalid_value)>::type* <anonymous> = 0; Types = {int, double}]\u2019:\r\ninclude/mapbox/variant.hpp:472:51:   required from \u2018static R mapbox::util::detail::binary_dispatcher<F, V, R, T, Types ...>::apply_const(const V&, const V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; T = int; Types = {double}]\u2019\r\ninclude/mapbox/variant.hpp:893:73:   required from \u2018static decltype (mapbox::util::detail::binary_dispatcher<F, V, R, Types ...>::apply_const(v0, v1, forward<F>(f))) mapbox::util::variant<Types>::binary_visit(const V&, const V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; Types = {int, double}; decltype (mapbox::util::detail::binary_dispatcher<F, V, R, Types ...>::apply_const(v0, v1, forward<F>(f))) = double]\u2019\r\ninclude/mapbox/variant.hpp:987:27:   required from \u2018decltype (V:: binary_visit(v0, v1, forward<F>(f))) mapbox::util::apply_visitor(F&&, const V&, const V&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; decltype (V:: binary_visit(v0, v1, forward<F>(f))) = double]\u2019\r\ntest/t/binary_visitor_impl.hpp:28:5:   required from here\r\ninclude/mapbox/variant.hpp:737:16: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]\r\n         return *reinterpret_cast<T const*>(&data);\r\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ninclude/mapbox/variant.hpp: In instantiation of \u2018T& mapbox::util::variant<Types>::get_unchecked() [with T = int; typename std::enable_if<(mapbox::util::detail::direct_type<T, Types ...>::index != mapbox::util::detail::invalid_value)>::type* <anonymous> = 0; Types = {int, double}]\u2019:\r\ninclude/mapbox/variant.hpp:493:45:   required from \u2018static R mapbox::util::detail::binary_dispatcher<F, V, R, T, Types ...>::apply(V&, V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; T = int; Types = {double}]\u2019\r\ninclude/mapbox/variant.hpp:900:67:   required from \u2018static decltype (mapbox::util::detail::binary_dispatcher<F, V, R, Types ...>::apply(v0, v1, forward<F>(f))) mapbox::util::variant<Types>::binary_visit(V&, V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; Types = {int, double}; decltype (mapbox::util::detail::binary_dispatcher<F, V, R, Types ...>::apply(v0, v1, forward<F>(f))) = double]\u2019\r\ninclude/mapbox/variant.hpp:994:27:   required from \u2018decltype (V:: binary_visit(v0, v1, forward<F>(f))) mapbox::util::apply_visitor(F&&, V&, V&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; decltype (V:: binary_visit(v0, v1, forward<F>(f))) = double]\u2019\r\ntest/t/binary_visitor_impl.hpp:68:5:   required from here\r\ninclude/mapbox/variant.hpp:713:16: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]\r\n         return *reinterpret_cast<T*>(&data);\r\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ninclude/mapbox/variant.hpp: In instantiation of \u2018const T& mapbox::util::variant<Types>::get_unchecked() const [with T = double; typename std::enable_if<(mapbox::util::detail::direct_type<T, Types ...>::index != mapbox::util::detail::invalid_value)>::type* <anonymous> = 0; Types = {int, double}]\u2019:\r\ninclude/mapbox/variant.hpp:401:44:   required from \u2018static R mapbox::util::detail::binary_dispatcher_rhs<F, V, R, T0, T1>::apply_const(const V&, const V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; T0 = int; T1 = double]\u2019\r\ninclude/mapbox/variant.hpp:477:80:   required from \u2018static R mapbox::util::detail::binary_dispatcher<F, V, R, T, Types ...>::apply_const(const V&, const V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; T = int; Types = {double}]\u2019\r\ninclude/mapbox/variant.hpp:893:73:   required from \u2018static decltype (mapbox::util::detail::binary_dispatcher<F, V, R, Types ...>::apply_const(v0, v1, forward<F>(f))) mapbox::util::variant<Types>::binary_visit(const V&, const V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; Types = {int, double}; decltype (mapbox::util::detail::binary_dispatcher<F, V, R, Types ...>::apply_const(v0, v1, forward<F>(f))) = double]\u2019\r\ninclude/mapbox/variant.hpp:987:27:   required from \u2018decltype (V:: binary_visit(v0, v1, forward<F>(f))) mapbox::util::apply_visitor(F&&, const V&, const V&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; decltype (V:: binary_visit(v0, v1, forward<F>(f))) = double]\u2019\r\ntest/t/binary_visitor_impl.hpp:28:5:   required from here\r\ninclude/mapbox/variant.hpp:737:16: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]\r\n         return *reinterpret_cast<T const*>(&data);\r\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ninclude/mapbox/variant.hpp: In instantiation of \u2018T& mapbox::util::variant<Types>::get_unchecked() [with T = double; typename std::enable_if<(mapbox::util::detail::direct_type<T, Types ...>::index != mapbox::util::detail::invalid_value)>::type* <anonymous> = 0; Types = {int, double}]\u2019:\r\ninclude/mapbox/variant.hpp:407:38:   required from \u2018static R mapbox::util::detail::binary_dispatcher_rhs<F, V, R, T0, T1>::apply(V&, V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; T0 = int; T1 = double]\u2019\r\ninclude/mapbox/variant.hpp:498:74:   required from \u2018static R mapbox::util::detail::binary_dispatcher<F, V, R, T, Types ...>::apply(V&, V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; T = int; Types = {double}]\u2019\r\ninclude/mapbox/variant.hpp:900:67:   required from \u2018static decltype (mapbox::util::detail::binary_dispatcher<F, V, R, Types ...>::apply(v0, v1, forward<F>(f))) mapbox::util::variant<Types>::binary_visit(V&, V&, F&&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; R = double; Types = {int, double}; decltype (mapbox::util::detail::binary_dispatcher<F, V, R, Types ...>::apply(v0, v1, forward<F>(f))) = double]\u2019\r\ninclude/mapbox/variant.hpp:994:27:   required from \u2018decltype (V:: binary_visit(v0, v1, forward<F>(f))) mapbox::util::apply_visitor(F&&, V&, V&) [with F = const add_visitor&; V = mapbox::util::variant<int, double>; decltype (V:: binary_visit(v0, v1, forward<F>(f))) = double]\u2019\r\ntest/t/binary_visitor_impl.hpp:68:5:   required from here\r\ninclude/mapbox/variant.hpp:713:16: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]\r\n         return *reinterpret_cast<T*>(&data);\r\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\ncc1plus: all warnings being treated as errors\r\nmake: *** [Makefile:100: out/binary_visitor_1.o] Error 1\r\n```", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/148/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "commits": [], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": []}, "narizhny": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/145", "title": "Wrong AccessModifierOffset", "body": "Code style and \".clang-format\" file don't match.\r\nWe need to change \"AccessModifierOffset\" option to -4, or change offset in files.\r\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/145/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "commits": [{"url": "https://api.github.com/repos/mapbox/variant/commits/51fccd755b05ee9d3dec9da239acd15d0823c381", "message": "Add static_variant_cast, dynamic_variant_cast"}], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/111490102", "body": "Because i have 2 versions of dynamic cast - for references and for pointers, but one version for static cast. Constness in both cases is taken from the original object.", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/111490102/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/111495161", "body": "fixed", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/111495161/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}]}, "joto": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/136", "title": "Coverage report on travis doesn't work", "body": "See for instance https://travis-ci.org/mapbox/variant/jobs/188957587 . You have to expand the \"after_script\" to see this. The job itself doesn't fail, though.\r\n\r\nProtozero has the same problem with Python, but in that case the job fails.\r\n\r\n/cc @springmeyer ", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/136/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/88", "title": "Noexcept on operator=() is wrong", "body": "I think the `noexcept` on `operator()` [here](https://github.com/mapbox/variant/blob/c4e864cc122c4fcc9b1f7a8f68a34e465df9f922/variant.hpp#L644) is wrong. There are several operations involved which all might fail.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/88/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/84", "title": "Access via type", "body": "Our implementation of variant allows access via `get<type>()` even if the type appears several times in the variant. This can be potentially confusing and error prone, especially when type aliasing is involved. Say, you got a variant `variant<int32_t, int>`. Do you know what `get<int>()` will do? Does the architecture matter?\n\nWhat makes things even more confusing is the addition of special versions of `get` that unwrap `std::reference_wrapper` and `mapbox::util::recursive_wrapper` on the fly. And they get accessed using the underlying type. So having a `variant<recursive_wrapper<int>>` you can access that `int` using the somewhat magical `get<int>()`. What happens when you access a `variant<int, recursive_wrapper<int>>` using `get<int>()`?\n\nI do see the convenience these choices bring, but on the other hand, these could lead to really hard to find bugs. The upcoming standards \"solves\" the first issue by not allowing get-access through the types if the types are not unique. You have to use index-based access then, which we don't have. It doesn't have the second problem because it doesn't have those magic wrappers.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/84/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/83", "title": "Unify special cases for reference/recursive_wrapper", "body": "There are special cases for `std::reference_wrapper` and `recursive_wrapper` in two places. One is in the `get()` call, the other in `unwrapper` helper class used by the visitor apply functions. This looks to me like there should be a way to unify this code, so that there is only once place that has the special code used by `get()` and `apply_visitor()`.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/83/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/80", "title": "Implement swap.", "body": "In the current code there is no implementation for `swap()` which means `std::swap()` will be used. This should do the right thing (as long as the move constructor and move assignment do the right thing) and the [tests](https://github.com/mapbox/variant/blob/861faa8125ae7c2d9e41e33b3d5d97a17213c415/test/t/variant.cpp#L268-L300) show this.\n\nBut this solution is not optimal, because the default `std::swap()` will always do one move construction and two move assignments (in this case of the variant). If there is a more efficient `swap` for the type in the variant, it will not be used. The upcoming standard [P0088R0](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0088r0.pdf) describes the effects of swap as: \"if `index() == rhs.index()`, calls `swap(get<i>(*this), get<i>(hrs))` with `i` being `index()`. Else calls `swap(*this, hrs)`.\"\n\nWe might want to implement our own `swap` in the future.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/80/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/61", "title": "Noexcept on constructor", "body": "The constructor for `variant` is declared `noexcept` which is only true if the constructor for the underlying type is noexcept. Because we don't know which type that will be we can only mark the constructor noexcept if all underlying types have a noexcept constructor.\n\nhttps://github.com/mapbox/variant/blob/861faa8125ae7c2d9e41e33b3d5d97a17213c415/variant.hpp#L584-L590\n\nThere is a comment `// nothrow` in there. It is unclear what it means. Maybe it was meant to say that we expect the constructor to be \"nothrow\", but that really must be encoded in code.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/61/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "commits": [], "pull_requests": [], "issue_comments": [{"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34894120", "body": "data_t and helper_t still in there.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34894120/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34894483", "body": "format should be \"T const&\"\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34894483/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34959837", "body": "But what if the real type in the variant is not a POD? Then this will not call the right swap.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34959837/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "commit_comments": [], "review_comments": []}, "daniel-j-h": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/131", "title": "Hashable should take type index into account", "body": "Hashing a variant should take the type index / `.which()` into account in addition to the underlying hash\r\n\r\n- https://github.com/mapbox/variant/blob/02bd1ac4c07e6db9fe0f01267853e43b41637b74/include/mapbox/variant.hpp#L1002-L1011\r\n- https://github.com/mapbox/variant/blob/02bd1ac4c07e6db9fe0f01267853e43b41637b74/include/mapbox/variant.hpp#L536-L544\r\n\r\nWhy? Because of the edge case where the underlying hash is the same but the type index is not.", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/131/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/127", "title": "Checks Concepts - Error Messages", "body": "While working on https://github.com/mapbox/variant/pull/126 I tested what happens if `Ts` are not Hashable.\r\nTurns out the error messages are pretty bad - as expected.\r\n\r\nThis is true for all features relying on the underlying types. Could e.g. be comparing variants for equality and then variant's `operator==` fails to compile since the underlying types are not comparable.\r\n\r\nHere is what we could do: emulate Concepts via Expression SFINAE and use them to provide beautiful error messages. Here is a first example of how this could look on the Hashable side:\r\n\r\n```c++\r\nstruct hasher\r\n{\r\n    template <typename T, typename = void>\r\n    struct is_hashable : std::false_type {};\r\n\r\n    template <typename T>\r\n    struct is_hashable<T, decltype((void)std::hash<T>{}(std::declval<T>()))> : std::true_type {};\r\n\r\n    template <typename T>\r\n    std::size_t operator()(const T& hashable) const\r\n    {\r\n        static_assert(is_hashable<T>::value, \"type is not hashable\");\r\n        return std::hash<T>{}(hashable);\r\n    }\r\n};\r\n```\r\n\r\nNow error messages are down to\r\n\r\n    ./include/mapbox/variant.hpp:547:9: error: static assertion failed: type is not hashable\r\n         static_assert(is_hashable<T>::value, \"type is not hashable\");\r\n\r\ninstead of coming from deep down in the stdlib's btree implementation just because you tried to put a variant into an unordered set. Similarly this would work for equality etc.\r\n\r\nNote: I'm not up to date on how far Expression SFINAE support is in Microsoft's VS, a couple of years ago is was a no go. Just something to be aware of. On the GCC / Clang side we're good.", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/127/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}], "commits": [], "pull_requests": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/142", "title": "Failing Test Case: std::move-ing out of variant", "body": "@anandthakker and I just had a discussion about move-ing types out of a variant.\r\n\r\nThink:\r\n\r\n```c++\r\nvariant<Container1, Container2> v;\r\n\r\nv.match([](Container1&& c1) { },\r\n        [](Container2&& c2) { });\r\n```\r\n\r\nWhich does not compile.\r\n\r\nI think the issue is [this type alias](https://github.com/mapbox/variant/blob/916139a2e51e125816efce6e19d428385601273f/include/mapbox/variant.hpp#L190) (and related), which do not take rvalue refs into account.", "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/130", "title": "Promotes Variant to mapbox:: Namespace \u2014 Closes #104", "body": "For https://github.com/mapbox/variant/issues/104 - cc @artemp @jfirebaugh\r\n\r\nIn a future version we want to remove the `mapbox::util::`\r\nnamespace. Until then we provide both adding a deprecation\r\nwarning to the readme.\r\n\r\nImplementation detail: we make the util namespace an `inline`\r\nnamespace - otherwise users could notice us changing the\r\nspecific namespace in which our templates were declared in.\r\n\r\nThe downside here is we can't add a deprecation pragma since\r\nthen the `mapbox::` namespace would contain it, too.", "author_association": "MEMBER"}], "issue_comments": [], "commit_comments": [], "review_comments": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/88733538", "body": "This got seriously out of hand - not sure what to do about it, though:\n- We need the `auto fn() -> decltype(expr) { return expr; }` pattern to support C++11, therefore we have to repeat `expr` twice. Once for the function's body, once to deduce the function's return type.\n- All the expression does is `return dispatcher<Lambdas, Self, ReturnType>::apply(*this, lambdas);` - we could introduce type aliases in the function body but the `decltype()` part still has to be a single expression\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/88733538/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/88742362", "body": "Um. Ha. Yes. Thanks for catching this ;)\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/88742362/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/92792807", "body": "Why `-Wno-unsequenced`?\r\n\r\nUnsequenced effects are an indicator for Undefined Behavior --- at which source location did this trigger?", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/92792807/reactions", "total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99356419", "body": "Is an `unsigned` really needed? Shouldn't a `uint8_t` be good enough as outlined in the ticket?\r\n\r\nAlso should we `static_assert` that users never use more types we can index?", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99356419/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/109151793", "body": "`lhs ,(void) rhs` required to prevent user overloaded `operator,` to trigger", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/109151793/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/111481274", "body": "Why do we need a result_type here but not above?", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/111481274/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/111481499", "body": "The formatting is a bit weird, did you use clang format?", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/111481499/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/124212335", "body": "Is there a reason you're leaving out the respective assignment operators?", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/124212335/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/126246887", "body": "Should we document all of variant's api here? For example there is an unchecked get, a function valid, and others. Related to that: should we document that get may throw an exception on error?\r\n\r\n(Btw not sure I'm the right person to review or make decisions here, all I did was implement the convenience match function and update the docs with some examples :P probably @artemp is good to tag for these kind of things)", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/126246887/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}]}, "lightmare": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/118", "title": "non-static variant::visit", "body": "I'm creating this separate issue to keep the discussion in #113 clean.\n\n> @artemp Because variant::visit doesn't modify internal state and making it static gives compiler some hints on how to generate binary code. Why are you thinking it shouldn't be static ?\n\nWhat hints? Visiting a non-const variant _can_ modify internal state (e.g. comparison operators can give different results after such visit; edit: that's modifying external state, actually).\n\n`visit` is a static member function template only by syntax. Its first argument is always a reference to the class it's defined in. That's identical to non-static member functions under the hood.\n\nWhy this:\n\n``` c++\ntemplate <typename F, typename V>\nauto VARIANT_INLINE apply_visitor(F&& f, V& v) -> decltype(V::visit(v, std::forward<F>(f)))\n{\n    return V::visit(v, std::forward<F>(f));\n}\n```\n\ninstead of this:\n\n``` c++\ntemplate <typename F, typename V>\nauto VARIANT_INLINE apply_visitor(F&& f, V& v) -> decltype(v.visit(std::forward<F>(f)))\n{\n    return v.visit(std::forward<F>(f));\n}\n```\n\n// ignoring for now that `V` should be forwarded as well\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/118/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "commits": [], "pull_requests": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/139", "title": "recursive variant move construction/assignment complexity", "body": "```\r\nout/recursive_wrapper_test 321000000\r\nTYPE OF RESULT-> TYPE_ID=N4test9binary_opINS_3subEEE\r\n1542000us\r\ntotal=321000000\r\n2+3-4=1\r\n----- sum of 1000 ones -----\r\nconstruction 57397us\r\ncalculation 7377us\r\ntotal=1000000\r\n----- sum of 5000 ones -----\r\nconstruction 1485368us\r\ncalculation 256442us\r\ntotal=25000000\r\n```\r\n\r\n```\r\nout/unique_ptr_test 321000000\r\nTYPE OF RESULT-> TYPE_ID=St10unique_ptrIN4test9binary_opINS0_3subEEESt14default_deleteIS3_EE\r\n840123us\r\ntotal=321000000\r\n2+3-4=1\r\n----- sum of 1000 ones -----\r\nconstruction 41us\r\ncalculation 5986us\r\ntotal=1000000\r\n----- sum of 5000 ones -----\r\nconstruction 171us\r\ncalculation 182640us\r\ntotal=25000000\r\n```\r\n\r\nLook at the times for \"construction\" of large trees.\r\nWith `recursive_wrapper` a 5x increase in tree size results in `1485368 / 57397 > 25x` increase in running time.\r\nWith `unique_ptr` the increase in running time is only `171 / 41 > 4x`.\r\n\r\nThere's one strange surprise, though. The first timing below TYPE is from an existing calculation test, and `unique_ptr` is almost twice as fast after the change (which doesn't touch any of that code), whereas before the change, there was no difference:\r\n```\r\nout/recursive_wrapper_test 321000000\r\nTYPE OF RESULT-> TYPE_ID=N4test9binary_opINS_3subEEE\r\n844526us\r\ntotal=321000000\r\n2+3-4=1\r\n```\r\n\r\n```\r\nout/unique_ptr_test 321000000\r\nTYPE OF RESULT-> TYPE_ID=St10unique_ptrIN4test9binary_opINS0_3subEEESt14default_deleteIS3_EE\r\n844189us\r\ntotal=321000000\r\n2+3-4=1\r\n```\r\n\r\nThat's with `gcc-6.2`. I previously tried with 4.8 and 5.4 and there were differences but not really convincing; `recursive_wrapper` was faster, then I slightly changed the code to only construct one `test::calculator` instead of constructing temporaries for every operation, and suddenly `unique_ptr` was faster; then I reverted that change, added the `bench_large_tree` function (without calling it) and the times were almost identical.\r\n", "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/93", "title": "call visitor with no argument if variant is uninitialized", "body": "If called on uninitialized variant, `apply_visitor` leads to dispatcher calling `get<T>` with the last alternative type, which throws.\n\nThis PR changes the behaviour so that the dispatcher either\n- throws with more helpful message \"apply_visitor on uninitialized variant\", or\n- calls the visitor with no arguments, if that is possible\n\nI also considered default-constructing the result type, instead of throwing, if the visitor cannot be called with no argument. That could work in some cases (e.g. when visitor extracts some value and default-constructed is okay; or when it applies some transformation and returns void), but could be very surprising in others, so I didn't include this \"feature\".\n", "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/91", "title": "add noexcept on assignment operators, and a test check those", "body": "You can check how the test ran on master here: https://travis-ci.org/lightmare/variant/builds/106630852\n\nWith this patch Travis/AppVeyor will still fail, that's intended.\n\nExcept for Xcode6 having some issue with `is_nothrow_move_constructible`, all other builds on travis will have only 2 failed `is_nothrow_destructible` checks. Those will go away once `~variant()` is declared `noexcept` (unconditionally), but I didn't wan't to touch that line so that it doesn't conflict with reverting previous commits or any other fix to the destructor issue.\n\nAppVeyor has more than 2 failing `is_nothrow_destructible`, that might mean it's indeed broken on MSVC and so the checks will need to be skipped/removed.\n\nNote: I removed private functions `copy_assign` and `move_assign` -- the names were misleading, they did destroy&construct, not assign -- and copied their bodies to respective operators.\n", "author_association": "CONTRIBUTOR"}], "issue_comments": [], "commit_comments": [], "review_comments": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/88736950", "body": "First step I'd take would be to simplify `dispatcher`. I think I've noted somewhere that it has more template parameters than necessary. `V` and `F` can be moved down, onto the apply function (and then there only needs to be one apply template matching both const and non-const variant). `R`, the result type, should be computed inside the `dispatcher` class.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/88736950/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/88738538", "body": "Um, actually the easiest thing you can do is call `visit` instead of duplicating it here. That'll hide all the dispatch ugliness.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/88738538/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}]}, "jfirebaugh": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/104", "title": "Promote to mapbox namespace (remove \"util\")", "body": "The extra level `util` namespace is unnecessary: we're not going to have a conflict on the name `variant` in the `mapbox` namespace, and `util` does not add any semantic information; all of our `mapbox`-namespaced projects are utilities of some kind.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/104/reactions", "total_count": 6, "+1": 6, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}], "commits": [], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/123798359", "body": "[In this context, `Fn&&` is an rvalue reference, not a universal reference.](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers) I believe that this will cause constructs such as the following to stop working:\r\n\r\n```\r\nauto lambda = [](...) { ... };\r\nrv.match(lambda);\r\n```\r\n\r\nCan you add a test for this?", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/123798359/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/124063653", "body": "How about:\r\n\r\n```C++\r\ntemplate <typename Fn>\r\nstruct visitor<Fn> : Fn\r\n{\r\n    template<typename T>\r\n    visitor(T&& fn) : Fn(std::forward<T>(fn)) {}    \r\n};\r\n\r\ntemplate <typename Fn, typename... Fns>\r\nstruct visitor<Fn, Fns...> : Fn, visitor<Fns...>\r\n{\r\n    template<typename T, typename... Ts>\r\n    visitor(T&& fn, Ts&&... fns)\r\n        : Fn(std::forward<T>(fn))\r\n        , visitor<Fns...>(std::forward<Ts>(fns)...) {}    \r\n};\r\n\r\ntemplate <typename... Fns>\r\nvisitor<std::decay<Fns>...> make_visitor(Fns&&... fns)\r\n{\r\n    return visitor<std::decay<Fns>...>(std::forward<Fns>(fns)...);\r\n}\r\n```", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/124063653/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}]}, "tomilov": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/89", "title": "Base recursive_wrapper implementation on std::unique_ptr", "body": "It is simpler to design `recursive_wrapper` as \"wrapper\" over ready-to-use to RAII `std::unique_ptr`. Just add value semantics ([example](https://github.com/tomilov/variant/blob/master/include/versatile/recursive_wrapper.hpp)).\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/89/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}], "commits": [], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99360031", "body": "On x86/x64 32-bit `int` may grant performance advantages over integers of another size (including `char`).", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99360031/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99361772", "body": "I think, for up to 256 alternative types variant's discriminatior type may be clearly expressed in terms of `uint_fast8_t` if speed is priority and `uint_least8_t` otherwise.", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99361772/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}]}, "artemp": {"issues": [{"url": "https://api.github.com/repos/mapbox/variant/issues/73", "title": "Remove `get_type_index` in favour of more standard `which()`", "body": "`get_type_index` returns index in reversed order which is confusing. \n`which` method is complaint with `boost::variant`. \n\nIn order to remove `get_type_index` we need to address last remaining issue - `invalid_type` value.\n\nProposed solution: \n\n``` c++\ninvalid_type == sizeof(Types...) + 1\n```\n\n``` c++\n// relevant test that needs upgrading\nREQUIRE(variant_type{mapbox::util::no_init()}.get_type_index() == mapbox::util::detail::invalid_value);\n```\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/73/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}], "commits": [{"url": "https://api.github.com/repos/mapbox/variant/commits/859a8c933a0c2ab18941acb9dcf834799c0de46c", "message": "Merge pull request #163 from MaxRis/master\n\nRemoves deprecated static_visitor to avoid msvc C4996 compiler warning"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/237f83cad2c76b1717ba4076c30aca32339336a8", "message": "Merge pull request #162 from mapbox/variant_alternative\n\nadd `variant_alternative` and `variant_size` implementations"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/835ebc19321c6a9696a2072b7fbd5ca3de818860", "message": "add `variant_size` helper"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/30560e19e60c23227b29bc3434a163d2343333d3", "message": "fix preprocessor logic"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/8b1de314711bff2f9f3c748ac0ed7cd7d6400331", "message": "add compile index in range check for __type_pack_element branch."}, {"url": "https://api.github.com/repos/mapbox/variant/commits/ae193141379c1706e17098c67c5b4e4f48b19c48", "message": "add optimized 'variant_alternative' implementation usinh built-in `__type_pack_element` when available (clang++)"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/3ffef950b005f31961f167242911b2f97d2634c3", "message": "add `variant_alternative_t`"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/3449d00cf525d8ef98cee0f4a276e2928398a8f9", "message": "alternative implementation of `variant_alternative`"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/4b98c485cf7d74691f7921145054641daa66936e", "message": "add lost test check + remove stderr"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/43357808cc93e69d2975e31e68986137ac5e88c9", "message": "add intial `variant_alternative` implementation (#161 http://en.cppreference.com/w/cpp/utility/variant/variant_alternative)"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/ba3085a5eb6e874d43432dc75f3392092e1e7214", "message": "use full sha1"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/75bb549d233eb94c74d2730dc3a8d8ed35c87f3d", "message": "update CHANGELOG\n(git log <tag1>...<tag2> --pretty=format:'* %s [view commit](http://github.com/mapbox/variant/commit/%H)' --reverse)"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/6497bce683e6e8edf80f80bc4fed65235690b335", "message": "add <sha1> to CHANGELOG entries."}, {"url": "https://api.github.com/repos/mapbox/variant/commits/555436f715e5e0929a13664f0911ecc4931356d1", "message": "add CHANGELOG.md skeleton"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/b78b51548743737357e5b3bbe296f465d5f4fdae", "message": "Merge pull request #154 from ricardocosme/forwarding_reference_make_visitor\n\nAdd move semantics to make_visitor and visitor"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/266f68d9f1c3ad65e6d6c264f0130bc4c652618a", "message": "Merge pull request #153 from ricardocosme/boost-build\n\nImprove Boost Build support"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/6247207595902dbf898a430346335af2a3485c74", "message": "add test for ref #147 + https://github.com/mapbox/variant/pull/147"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/e01b7bf3334e788fb99f4a510d5bc87a4a581342", "message": "Merge branch 'BlueSolei-master'"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/195367cfc19e1e08933487fa7cc56cb7f6d25cc8", "message": "Merge branch 'master' of https://github.com/BlueSolei/variant into BlueSolei-master"}, {"url": "https://api.github.com/repos/mapbox/variant/commits/ea106db54b167b8dce7c0b3b9b59bb06b209db33", "message": "recursive_wrapper test - avoid constructing new functor in recursive calls, call itself via `this` pointer."}, {"url": "https://api.github.com/repos/mapbox/variant/commits/291121f6ac682c6cc5a7a69f253492f03ca7324f", "message": "Merge pull request #144 from narizhny/Casts\n\nAdd variant_static_cast, variant_dynamic_cast"}], "pull_requests": [], "issue_comments": [{"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34892647", "body": "fixed in 41d5626bee25a4edd36c2e2d05bde46751417baa\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34892647/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34961341", "body": "this ons should be fixed in master \n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34961341/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/35483792", "body": "`struct` can have private members with `private` keyword. The only differences between `struct` and `class` are _default_ inheritance and members access specifiers are public for `struct` and private for `class`\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/35483792/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/41803073", "body": "@DennisOSRM - ha I was talking about it with @springmeyer yesterday, you read my mind :)\nDefinitely, we need one too in Mapnik. \n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/41803073/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44269831", "body": "@DennisOSRM - i'll take a look, the interface is a bit awkward at the moment.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44269831/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44417620", "body": "@DennisOSRM  interestingly, it compiles with \n`Apple LLVM version 5.0 (clang-500.2.79) (based on LLVM 3.3svn)`\nand `clang version 3.5.0 (trunk 208668)` for me\n\nI'll keep digging..\n\n^^ disregard, I had a patched variant. I fails for me too with master\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44417620/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44420510", "body": "your test-case compiles with this diff (which is wrong anyway)\n\n``` patch\ndiff --git a/variant.hpp b/variant.hpp\nindex 1885b4e..f7dec88 100644\n--- a/variant.hpp\n+++ b/variant.hpp\n@@ -384,8 +384,9 @@ public:\n     VARIANT_INLINE variant(T && val) noexcept\n         : type_id(detail::type_traits<T,Types...>::id)\n     {\n-        static_assert(detail::is_valid_type<T,Types...>::value, \"Not a valid type for this variant\");\n-        new (&data) T(std::forward<T>(val)); // nothrow\n+        //static_assert(detail::is_valid_type<T,Types...>::value, \"Not a valid type for this variant\");\n+        typedef typename std::remove_reference<T>::type value_type;\n+        new (&data) value_type(std::forward<value_type>(val)); // nothrow\n     }\n\n     VARIANT_INLINE variant(variant<Types...> const& old)\n@@ -524,7 +525,7 @@ auto VARIANT_INLINE static apply_visitor( F f, V const& v0, V const& v1) -> decl\n }\n\n\n-// operator<<\n+// variant operator<<\n template <typename charT, typename traits, typename Variant>\n VARIANT_INLINE std::basic_ostream<charT,traits>&\n operator<< (std::basic_ostream<charT,traits>& out, Variant const& rhs)\n```\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44420510/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44421043", "body": "``` c++\n//#include \"/Users/artem/Projects/variant/recursive_wrapper.hpp\"\n#include \"/Users/artem/Projects/variant/variant.hpp\"\n\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nstruct Number;\nstruct Object;\n\ntypedef util::variant<util::recursive_wrapper<Number>,\n                      util::recursive_wrapper<Object>> Value;\nstruct Number\n{\n    Number() {}\n    Number(double value) : value(value) {}\n    double value;\n};\n\nstd::ostream& operator<<(std::ostream & out, Number const& num)\n{\n    out << \"Number:\" << num.value;\n    return out;\n}\n\nstruct Object\n{\n    std::unordered_map<std::string, Value> values;\n};\n\nstd::ostream& operator<<(std::ostream & out, Object const& obj)\n{\n    out << \"Object\";\n    return out;\n}\n\nint main() {\n    Object object;\n    Number number {3.1415};\n    object.values[\"pi\"] = util::recursive_wrapper<Number>(number);\n    std::cerr << object.values[\"pi\"] << std::endl;\n    return 0;\n}\n```\n\nI modified your test and it compiles for me. At the moment `recursive_wrapper` need to be passed explicitly. I'll see how to improve syntax.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44421043/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45319643", "body": "@DennisOSRM - do you mean automatic conversions from `T` to `recursive_wrapper<T>` in assignment op? I'll take a look how boost is doing it.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45319643/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45485079", "body": "Note to myself - move_assign implementation and comments https://github.com/boostorg/variant/blob/master/include/boost/variant/variant.hpp#L2080-L2084\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45485079/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/46858786", "body": "@kkaefer - thanks for tracking this down!\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/46858786/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/46973125", "body": "@kkaefer  - non-const visitation 54d07c9\n\n``` c++\ntemplate <typename T>\nstruct mutating_visitor : util::static_visitor<>\n{\n    mutating_visitor(T & val)\n        : val_(val) {}\n\n    void operator() (T & val) const\n    {\n        val = val_;\n    }\n\n    template <typename T1>\n    void operator() (T1& ) const {} // no-op\n\n    T & val_;\n};\n\nutil::variant<int, double, std::string> var(123);\nREQUIRE(var.get<int>() == 123);\nint val = 456;\nmutating_visitor<int> visitor(val);\nutil::apply_visitor(visitor,var);\nREQUIRE(var.get<int>() == 456);\n```\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/46973125/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}], "commit_comments": [{"url": "https://api.github.com/repos/mapbox/variant/comments/15762486", "body": "@joto - good stuff outlining intentions etc\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/comments/15762486/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}], "review_comments": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99366655", "body": "`llvm/libc++` `<variant>` implementation uses `unsigned`.  \r\n> Shouldn't a uint8_t be good enough as outlined in the ticket? \r\n\r\nWe probably can but I favour something along `BOOST_OPTIMIZE_SIZE` compile flag to choose min suitable `type_index_t` at compile time. \r\n\r\n>I think, for up to 256 alternative types variant's discriminatior type may be clearly expressed in terms of uint_fast8_t if speed is priority and uint_least8_t otherwise.\r\n\r\nyep, sounds like an idea ^ \r\n\r\n/cc @daniel-j-h  @tomilov  ", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99366655/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99367484", "body": "@daniel-j-h - \r\n>Also should we static_assert that users never use more types we can index?\r\n\r\n\ud83d\udc4d  ", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/99367484/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/127658875", "body": "@anandthakker - thanks for the PR! I agree with @ricardocosme and @daniel-j-h  - it'll be better to have a separate page listing all available methods while `README` only mentions basic building blocks. ", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/127658875/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "MEMBER"}]}, "MaxRis": {"issues": [], "commits": [{"url": "https://api.github.com/repos/mapbox/variant/commits/215d64585ef92e16f18f5da81195b0279f53f599", "message": "Removes deprecated static_visitor to avoid msvc C4996 compiler warning"}], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": []}, "ricardocosme": {"issues": [], "commits": [{"url": "https://api.github.com/repos/mapbox/variant/commits/f0b50062b4fd2bf2b86aeada2efa8e36cfa6cb1c", "message": "Add copy assignment and move assignment operators."}, {"url": "https://api.github.com/repos/mapbox/variant/commits/9f991da78d3146d32be67695a89c2b1197c826b2", "message": "Use forwarding reference in make_visitor and visitor\n\nIt avoids internal copies of closures passed to make_visitor and it\npermits the usage of init capture(feature of C++14) to use movable\nonly types.\n\n - Add test case for lambda with init capture and movable(but not\n   copyable) object\n - Add test case for match() receiving a lvalue reference to a lambda."}, {"url": "https://api.github.com/repos/mapbox/variant/commits/04a6797a6aa2a86dd3eb6517893255c010f6e524", "message": "- Add auxiliar rule exe-test."}, {"url": "https://api.github.com/repos/mapbox/variant/commits/bd0a2d559724b8daa7d1ff33df90976e26a595aa", "message": "- Use of the module 'os' to get BOOST_DIR.\n- Add macro SINGLE_THREADED to single threading mode.\n- Define single threading mode as default.\n- Add lambda_overload_test and hashable_test."}, {"url": "https://api.github.com/repos/mapbox/variant/commits/561a09dd005468f9cdef651030471a1215f1885f", "message": "- Remove the use of boost libraries.\n- Add default build."}, {"url": "https://api.github.com/repos/mapbox/variant/commits/b2471ffc74c163194943b17b2b2c5758c59655ca", "message": "- Add a project mapbox_variant.\n- Use of the 'os' module to capture CXX_STD.\n- Common configs moved to project.\n- Built targets moved to 'out' directory."}], "pull_requests": [], "issue_comments": [], "commit_comments": [], "review_comments": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/123867732", "body": "Thank you @jfirebaugh, you're right!\r\nYour test gives me a `Fn` deduced as a `lambda&`.\r\nI included your case to `test_match_singleton()` and added some more cases to `test_match_overloads_init_capture()`. \r\n\r\nThere is a fix at d4cd55a897f24feb2a2bdb2a9b16cba7a414c0b7. Can you take a look, please?", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/123867732/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/123878803", "body": "### Improvement\r\nIt should be possible to avoid some calls to move ctor using visitor ctor with forwarding references(not rvalue refs.) and decayed types(i.e., `std::decay`) to permit inheritance of Fn and access to Fn::operator(). I believe this is safe here. [A draft to this approach.](https://gist.github.com/ricardocosme/a84fe41206f5ff849eab91463af75650)\r\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/123878803/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/124179275", "body": "Nice, it's simpler this way. Pull request has been updated. 9f991da78d3146d32be67695a89c2b1197c826b2", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/124179275/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/124291503", "body": "Thanks @daniel-j-h! We're not actually using the assignment operator in the test, but it's important to an object tagged as movable and/or copyable. Pull request has been updated.", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/124291503/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/126253649", "body": "My two cents. I don't think `is<T>()` is so basic to stay here. The section is about basic building blocks. I believe this is more interesting to `mapox/variant.hpp`.", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/pulls/comments/126253649/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}]}, "mlogan": {"issues": [], "commits": [], "pull_requests": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/160", "title": "Fix the noexcept specifications for move assignment and conversion.", "body": "This should allow variants to be nothrow move-assignable where appropriate.\r\n\r\nI also took a crack at fixing the noexcept spec on the conversion assignment operator, which could previously lie. I definitely don't understand the meta-programming used here, so comments are welcome.", "author_association": "NONE"}], "issue_comments": [], "commit_comments": [], "review_comments": []}, "daminetreg": {"issues": [], "commits": [], "pull_requests": [{"url": "https://api.github.com/repos/mapbox/variant/pulls/119", "title": "Useful traits and Boost.Spirit Qi/Karma support headers for mapbox::variant.", "body": "Dear Mapbox Variant authors,\n\nI would like to contribute support headers for Boost.Spirit.Qi and Karma to mapbox::variant, so that usage of Mapbox::variant with Qi and Karma get really easy. \n## Why ?\n- Currently if you have a really large variant type (e.g. more as 50) with Boost.Spirit you need to re-preprocess the Boost.Mpl headers to enable your type to be compiled with Boost.Variant.\n- Meaning you need a Patched Boost. With all the problems it brings when you are a lib publisher.\n- Bigger mpl::vector<> for a bigger Boost.Variant makes the compile times of qi::rule and karma::rule decrease significantly.\n- It also has strong impact on binary sizes, that with MapBox::Variant gets away. :smile:\n\n| small test program with | Boost.Variant | MapBox.Variant |\n| --- | --- | --- |\n| Boost.Spirit Qi | 75 Kb | 63 Kb |\n| Boost.Spirit Karma | 119 Kb | 83 Kb |\n\n[See benchmark code here](https://github.com/sauter-hq/boost-spirit-mapbox-variant)\n\nSo I updated a big codebase which was using Boost.Variant and Boost.Spirit together with Mapbox::variant. And now it compiles faster, makes smaller binaries and we don't need a patched Boost MPL anymore ! :grinning: Thank you very much for this variant type.\n## Features\n\nThe small supporting headers I wrote might be useful for users of this library, therefore I would like to contribute the following to Mapbox::Variant : \n1. [A metafunction](https://github.com/sauter-hq/variant/blob/8c0cc0315d0d6fbb102d1bbcbf355ded1334e5fe/include/mapbox/traits/is_mapbox_variant.hpp) to detect whether some type is a mapbox::variant\n2. [A metafunction](https://github.com/sauter-hq/variant/blob/8c0cc0315d0d6fbb102d1bbcbf355ded1334e5fe/include/mapbox/traits/is_type_in_variant.hpp) to check if a type is part of a variant.\n3. One supporting header for Boost.Spirit.Qi, defining the required traits\n4. One supporting header for Boost.Spirit.Karma,  defining the required traits.\n\nI would naturally understand that the supporting header for Qi and Karma are not interesting you as part of the library, as they base on the Boost.Spirit traits which are documented only in spirit code but which are used extensively internally by the library and provided as supporting headers since ages (https://github.com/boostorg/spirit/blob/develop/include/boost/spirit/home/support/extended_variant.hpp).\n\nFollowing if you are interested in the supporting headers for Boost.Spirit or not I will publish them as a separate library and remove 3. and 4. from this PR. \n\nBut I really would love to see the `include/mapbox/traits/is_mapbox_variant.hpp` and `include/mapbox/traits/is_type_in_variant.hpp` accepted, as they are in my opinion features that should be part of Mapbox Variant.\n\nYou can test out the supporting headers by running : \n- `make out/boost_spirit_karma && out/boost_spirit_karma`\n- `make out/boost_spirit_qi && out/boost_spirit_karma`\n\nCheers\n", "author_association": "NONE"}], "issue_comments": [], "commit_comments": [], "review_comments": []}, "DennisOSRM": {"issues": [], "commits": [], "pull_requests": [], "issue_comments": [{"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34956281", "body": "Yes, this will work. `std::aligned_storage<T>` behaves like a POD:\n\n![bildschirmfoto 2014-02-13 um 09 05 47](https://f.cloud.github.com/assets/1067895/2157806/c12fb9d8-9485-11e3-9b40-4bd4e5083ba7.png)\n\nAdmittedly, the [`using std::swap`](https://github.com/artemp/variant/blob/master/variant.hpp#L264) is overkill as there is not much ADL to do on PODs, but let's consider that good style.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/34956281/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/41803188", "body": "awesome, it would allow me to ditch yet another boost dependency in OSRM. (not that boost is bad at all)\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/41803188/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/43558151", "body": "Cool! Thanks for implementing this. I'll give it a try tomorrow. \n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/43558151/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/43942693", "body": "Awesome!\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/43942693/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44199553", "body": "still triggers the static assertion. I have the feeling, it will need some `std::remove_reference` massaging.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/44199553/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45302631", "body": "Not yet. Will give it another shot this morning. \n\n> Am 06.06.2014 um 03:07 schrieb Dane Springmeyer notifications@github.com:\n> \n> @DennisOSRM - had a change to try this out again?\n> \n> \u2014\n> Reply to this email directly or view it on GitHub.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45302631/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45313594", "body": "@artemp @springmeyer it does work, thanks.\n\nHow hard would it be to add an (automatic) casts?\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45313594/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}, {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45320151", "body": "> do you mean automatic conversions from T to recursive_wrapper<T> in assignment op\n\nyes, that's what I meant.\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45320151/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "commit_comments": [{"url": "https://api.github.com/repos/mapbox/variant/comments/8224310", "body": ":+1: \n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/comments/8224310/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "review_comments": []}, "kkaefer": {"issues": [], "commits": [], "pull_requests": [], "issue_comments": [{"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45321336", "body": "+1 on automatic recursive wrapping\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/issues/comments/45321336/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "CONTRIBUTOR"}], "commit_comments": [], "review_comments": []}, "kirbyfan64": {"issues": [], "commits": [], "pull_requests": [], "issue_comments": [], "commit_comments": [{"url": "https://api.github.com/repos/mapbox/variant/comments/15764398", "body": "Shouldn't this be \"the upcoming variant standard**,** because\"?\n", "reactions": {"url": "https://api.github.com/repos/mapbox/variant/comments/15764398/reactions", "total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "hooray": 0, "confused": 0, "heart": 0}, "author_association": "NONE"}], "review_comments": []}}}}